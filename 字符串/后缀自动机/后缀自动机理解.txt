1.给定文本串T,问T中是否存在子串P
从初始状态开始转移，当前状态没有要求的字符转移，那么答案就是“no”

2.给定字符串S，问它有多少不同的子串
任意一个子串对应自动机中的一条路径，答案为从初始状态开始，自动机中的路径数
因为后缀自动机是一张又向无环图，可以用dp来计算不同的路径数
dp[v]:表示从状态v出发的路径数(包括长度为0的串)
dp[v] = 1+sum(dp[u]) v-->u;
答案为dp[s]-1;

3.给定字符串，求其所有不同子串的总长度
考虑两个状态：不同子串的个数d[v]和他们的总长ans[v].
ans[v] = sum(d[u]+ans[u]) v-->u;

4.给定字符串s，问s的所有子串排序后第k大的
字典序第k小的子串--自动机中第k小的路径，考虑从每个状态出发的不同路径数

5.给定字符串s，找到和它循环同构的字典序最小字符串
将字符串s+s建立后缀自动机。该自动机将包含和s循环同构的所有字符串
从而问题变成在自动机中找出字典序最小，长度为len(s)的路径.

6.给定文本串T：问字符串p在T中出现的次数(出现次数可以相交)
计算每个状态的cnt[v](endpos(v)集合的大小)
答案为对应状态的cnt值
那么如何计算cnt
对于每个状态，若不是拷贝而来，则cnt = 1，否则cnt = 0
然后按长度len降序遍历所有序列，并将当前的cnt[v]加给后缀链接，cnt[link[v]] += cnt[u]。

